{"version":3,"sources":["../../../../src/tileset/helpers/frame-state.ts"],"names":["scratchVector","Vector3","scratchPosition","cullingVolume","CullingVolume","Plane","getFrameState","viewport","frameNumber","cameraDirection","cameraUp","height","metersPerUnit","distanceScales","viewportCenterCartographic","unprojectPosition","center","viewportCenterCartesian","Ellipsoid","WGS84","cartographicToCartesian","enuToFixedTransform","eastNorthUpToFixedFrame","cameraPositionCartographic","cameraPosition","cameraPositionCartesian","cameraDirectionCartesian","transformAsVector","scale","normalize","cameraUpCartesian","commonSpacePlanesToWGS84","ViewportClass","constructor","longitude","latitude","width","bearing","zoom","topDownViewport","pitch","camera","position","direction","up","sseDenominator","limitSelectedTiles","tiles","frameState","maximumTilesSelected","length","tuples","viewportLongitude","viewportLatitude","entries","index","tile","header","mbs","deltaLon","Math","abs","deltaLat","distance","sqrt","push","tuplesSorted","sort","a","b","selectedTiles","i","unselectedTiles","frustumPlanes","getFrustumPlanes","dir","plane","distanceToCenter","normal","dot","copy","add","cartographicPos","cartesianPos","planes","fromPointNormal","subtract"],"mappings":"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","sourcesContent":["import {Tile3D} from '@loaders.gl/tiles';\nimport {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: {[key: string]: any};\n  topDownViewport: {[key: string]: any}; // Use it to calculate projected radius for a tile\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  const viewportCenterCartographic = viewport.unprojectPosition(viewport.center);\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    viewportCenterCartographic,\n    new Vector3()\n  );\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport, viewportCenterCartesian);\n\n  const ViewportClass = viewport.constructor;\n  const {longitude, latitude, width, bearing, zoom} = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(\n  tiles: Tile3D[],\n  frameState: FrameState,\n  maximumTilesSelected: number\n): [Tile3D[], Tile3D[]] {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples: [number, number][] = [];\n  const {longitude: viewportLongitude, latitude: viewportLatitude} = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles: Tile3D[] = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles: Tile3D[] = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  return [selectedTiles, unselectedTiles];\n}\n\nfunction commonSpacePlanesToWGS84(viewport, viewportCenterCartesian) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n  let i = 0;\n  for (const dir in frustumPlanes) {\n    const plane = frustumPlanes[dir];\n    const distanceToCenter = plane.normal.dot(viewport.center);\n    scratchPosition\n      .copy(plane.normal)\n      .scale(plane.distance - distanceToCenter)\n      .add(viewport.center);\n    const cartographicPos = viewport.unprojectPosition(scratchPosition);\n\n    const cartesianPos = Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, new Vector3());\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(viewportCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n"],"file":"frame-state.js"}