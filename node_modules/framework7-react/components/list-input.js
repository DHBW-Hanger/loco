function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { forwardRef, useRef, useImperativeHandle, useState, useContext } from 'react';
import { useIsomorphicLayoutEffect } from '../shared/use-isomorphic-layout-effect.js';
import { classNames, getExtraAttrs, emit, getSlots, extend } from '../shared/utils.js';
import { colorClasses } from '../shared/mixins.js';
import { f7ready, f7 } from '../shared/f7.js';
import TextEditor from './text-editor.js';
import { watchProp } from '../shared/watch-prop.js';
import { ListContext } from '../shared/list-context.js';


const ListInput = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    id,
    style,
    sortable,
    media,
    dropdown = 'auto',
    wrap = true,
    // Inputs
    input: renderInput = true,
    type = 'text',
    name,
    value,
    defaultValue,
    inputmode,
    readonly,
    required,
    disabled,
    placeholder,
    inputId,
    size,
    accept,
    autocomplete,
    autocorrect,
    autocapitalize,
    spellcheck,
    autofocus,
    autosave,
    max,
    min,
    step,
    maxlength,
    minlength,
    multiple,
    inputStyle,
    pattern,
    validate,
    validateOnBlur,
    onValidate,
    tabindex,
    resizable,
    clearButton,
    // Form
    noFormStoreData,
    noStoreData,
    ignoreStoreData,
    // Error, Info
    errorMessage,
    errorMessageForce,
    info,
    // Outline
    outline,
    // Label
    label,
    inlineLabel,
    floatingLabel,
    // Datepicker
    calendarParams,
    // Colorpicker
    colorPickerParams,
    // Text editor
    textEditorParams
  } = props;
  const [inputInvalid, setInputInvalid] = useState(false);
  const [inputFocused, setInputFocused] = useState(false);
  const listContext = useContext(ListContext);
  const {
    listIsSortable = false
  } = listContext || {};
  const extraAttrs = getExtraAttrs(props);
  const f7Calendar = useRef(null);
  const f7ColorPicker = useRef(null);
  const elRef = useRef(null);
  const inputElRef = useRef(null);
  const itemContentElRef = useRef(null);
  const updateInputOnDidUpdate = useRef(false);

  const getDomValue = () => {
    if (!inputElRef.current) return undefined;
    return inputElRef.current.value;
  };

  const isInputHasValue = () => {
    if (type === 'datepicker' && Array.isArray(value) && value.length === 0) {
      return false;
    }

    const domValue = getDomValue();
    return typeof value === 'undefined' ? domValue || domValue === 0 : value || value === 0;
  };

  const validateInput = () => {
    if (!f7 || !inputElRef.current) return;
    const validity = inputElRef.current.validity;
    if (!validity) return;

    if (!validity.valid) {
      if (onValidate) onValidate(false);

      if (inputInvalid !== true) {
        setInputInvalid(true);
      }
    } else {
      if (onValidate) onValidate(true);

      if (inputInvalid !== false) {
        setInputInvalid(false);
      }
    }
  };

  const onTextareaResize = event => {
    emit(props, 'textareaResize', event);
  };

  const onInputNotEmpty = event => {
    emit(props, 'inputNotEmpty', event);
  };

  const onInputEmpty = event => {
    emit(props, 'inputEmpty', event);
  };

  const onInputClear = event => {
    emit(props, 'inputClear', event);
  };

  const onInput = function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    emit(props, 'input', ...args);

    if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && inputElRef.current) {
      validateInput(inputElRef.current);
    }
  };

  const onFocus = function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    emit(props, 'focus', ...args);
    setInputFocused(true);
  };

  const onBlur = function () {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    emit(props, 'blur', ...args);

    if ((validate || validate === '' || validateOnBlur || validateOnBlur === '') && inputElRef.current) {
      validateInput(inputElRef.current);
    }

    setInputFocused(false);
  };

  const onChange = function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    emit(props, 'change', ...args);

    if (type === 'texteditor') {
      emit(props, 'textEditorChange', args[0]);
    }
  };

  useImperativeHandle(ref, () => ({
    el: elRef.current
  }));

  const onMount = () => {
    if (!elRef.current && !itemContentElRef.current) return;
    f7ready(() => {
      if (!inputElRef.current) return;
      inputElRef.current.addEventListener('input:notempty', onInputNotEmpty, false);
      inputElRef.current.addEventListener('textarea:resize', onTextareaResize, false);
      inputElRef.current.addEventListener('input:empty', onInputEmpty, false);
      inputElRef.current.addEventListener('input:clear', onInputClear, false);

      if (type === 'datepicker') {
        f7Calendar.current = f7.calendar.create({
          inputEl: inputElRef.current,
          value,
          on: {
            change(calendar, calendarValue) {
              emit(props, 'calendarChange', calendarValue);
            }

          },
          ...(calendarParams || {})
        });
      }

      if (type === 'colorpicker') {
        f7ColorPicker.current = f7.colorPicker.create({
          inputEl: inputElRef.current,
          value,
          on: {
            change(colorPicker, colorPickerValue) {
              emit(props, 'colorpicker:change colorPickerChange', colorPickerValue);
            }

          },
          ...(colorPickerParams || {})
        });
      }

      if (!(validateOnBlur || validateOnBlur === '') && (validate || validate === '') && (typeof value !== 'undefined' && value !== null && value !== '' || typeof defaultValue !== 'undefined' && defaultValue !== null && defaultValue !== '')) {
        setTimeout(() => {
          validateInput();
        }, 0);
      }

      if (type === 'textarea' && resizable) {
        f7.input.resizeTextarea(inputElRef.current);
      }
    });
  };

  const onDestroy = () => {
    if (inputElRef.current) {
      inputElRef.current.removeEventListener('input:notempty', onInputNotEmpty, false);
      inputElRef.current.removeEventListener('textarea:resize', onTextareaResize, false);
      inputElRef.current.removeEventListener('input:empty', onInputEmpty, false);
      inputElRef.current.removeEventListener('input:clear', onInputClear, false);
    }

    if (f7Calendar.current && f7Calendar.current.destroy) {
      f7Calendar.current.destroy();
      f7Calendar.current = null;
    }

    if (f7ColorPicker.current && f7ColorPicker.current.destroy) {
      f7ColorPicker.current.destroy();
      f7ColorPicker.current = null;
    }
  };

  useIsomorphicLayoutEffect(() => {
    onMount();
    return onDestroy;
  }, []);
  useIsomorphicLayoutEffect(() => {
    if (!f7) return;

    if (updateInputOnDidUpdate.current) {
      if (!inputElRef.current) return;
      updateInputOnDidUpdate.current = false;

      if (validate && !validateOnBlur) {
        validateInput();
      }

      if (type === 'textarea' && resizable) {
        f7.input.resizeTextarea(inputElRef.current);
      }
    }
  });
  watchProp(colorPickerParams, newValue => {
    if (!f7 || !f7ColorPicker.current) return;
    extend(f7ColorPicker.current.params, newValue || {});
  });
  watchProp(calendarParams, newValue => {
    if (!f7 || !f7Calendar.current) return;
    extend(f7Calendar.current.params, newValue || {});
  });
  watchProp(value, newValue => {
    if (!f7) return;
    updateInputOnDidUpdate.current = true;

    if (f7Calendar.current) {
      f7Calendar.current.setValue(newValue);
    }

    if (f7ColorPicker.current) {
      f7ColorPicker.current.setValue(newValue);
    }
  });
  const slots = getSlots(props);
  const domValue = getDomValue();
  const inputHasValue = isInputHasValue();
  const isSortableComputed = sortable === true || sortable === false ? sortable : listIsSortable;
  let inputEl;

  const createInput = (InputTag, children) => {
    const needsValue = type !== 'file' && type !== 'datepicker' && type !== 'colorpicker';
    const needsType = InputTag === 'input';
    let inputType = type;

    if (inputType === 'datepicker' || inputType === 'colorpicker') {
      inputType = 'text';
    }

    const inputClassName = classNames({
      resizable: inputType === 'textarea' && resizable,
      'no-store-data': noFormStoreData || noStoreData || ignoreStoreData,
      'input-invalid': errorMessage && errorMessageForce || inputInvalid,
      'input-with-value': inputHasValue,
      'input-focused': inputFocused
    });
    let inputValue;

    if (needsValue) {
      if (typeof value !== 'undefined') inputValue = value;else inputValue = domValue;
    }

    const valueProps = {};

    if (type !== 'datepicker' && type !== 'colorpicker') {
      if ('value' in props) valueProps.value = inputValue;
      if ('defaultValue' in props) valueProps.defaultValue = defaultValue;
    }

    return /*#__PURE__*/React.createElement(InputTag, _extends({
      ref: inputElRef,
      style: inputStyle,
      name: name,
      type: needsType ? inputType : undefined,
      placeholder: placeholder,
      inputMode: inputmode,
      id: inputId,
      size: size,
      accept: accept,
      autoComplete: autocomplete,
      autoCorrect: autocorrect,
      autoCapitalize: autocapitalize,
      spellCheck: spellcheck,
      autoFocus: autofocus,
      autoSave: autosave,
      disabled: disabled,
      max: max,
      maxLength: maxlength,
      min: min,
      minLength: minlength,
      step: step,
      multiple: multiple,
      readOnly: readonly,
      required: required,
      pattern: pattern,
      validate: typeof validate === 'string' && validate.length ? validate : undefined,
      "data-validate": validate === true || validate === '' || validateOnBlur === true || validateOnBlur === '' ? true : undefined,
      "data-validate-on-blur": validateOnBlur === true || validateOnBlur === '' ? true : undefined,
      tabIndex: tabindex,
      "data-error-message": errorMessageForce ? undefined : errorMessage,
      className: inputClassName,
      onFocus: onFocus,
      onBlur: onBlur,
      onInput: onInput,
      onChange: onChange
    }, valueProps), children);
  };

  if (renderInput) {
    if (type === 'select' || type === 'textarea' || type === 'file') {
      if (type === 'select') {
        inputEl = createInput('select', slots.default);
      } else if (type === 'file') {
        inputEl = createInput('input');
      } else {
        inputEl = createInput('textarea');
      }
    } else if (type === 'texteditor') {
      inputEl = /*#__PURE__*/React.createElement(TextEditor, _extends({
        value: value,
        resizable: resizable,
        placeholder: placeholder,
        onTextEditorFocus: onFocus,
        onTextEditorBlur: onBlur,
        onTextEditorInput: onInput,
        onTextEditorChange: onChange
      }, textEditorParams || {}));
    } else {
      inputEl = createInput('input');
    }
  }

  const hasErrorMessage = !!errorMessage || slots['error-message'] && slots['error-message'].length;
  const ItemContent = /*#__PURE__*/React.createElement("div", {
    ref: itemContentElRef,
    className: classNames('item-content item-input', !wrap && className, !wrap && {
      disabled
    }, !wrap && colorClasses(props), {
      'inline-label': inlineLabel,
      'item-input-outline': outline,
      'item-input-focused': inputFocused,
      'item-input-with-info': !!info || slots.info && slots.info.length,
      'item-input-with-value': inputHasValue,
      'item-input-with-error-message': hasErrorMessage && errorMessageForce || inputInvalid,
      'item-input-invalid': hasErrorMessage && errorMessageForce || inputInvalid
    })
  }, slots['content-start'], (media || slots.media) && /*#__PURE__*/React.createElement("div", {
    className: "item-media"
  }, media && /*#__PURE__*/React.createElement("img", {
    src: media
  }), slots.media), /*#__PURE__*/React.createElement("div", {
    className: "item-inner"
  }, slots['inner-start'], (label || slots.label) && /*#__PURE__*/React.createElement("div", {
    className: classNames('item-title item-label', {
      'item-floating-label': floatingLabel
    })
  }, label, slots.label), /*#__PURE__*/React.createElement("div", {
    className: classNames('item-input-wrap', {
      'input-dropdown': dropdown === 'auto' ? type === 'select' : dropdown
    })
  }, inputEl, slots.input, hasErrorMessage && errorMessageForce && /*#__PURE__*/React.createElement("div", {
    className: "item-input-error-message"
  }, errorMessage, slots['error-message']), clearButton && /*#__PURE__*/React.createElement("span", {
    className: "input-clear-button"
  }), (info || slots.info) && /*#__PURE__*/React.createElement("div", {
    className: "item-input-info"
  }, info, slots.info)), slots.inner, slots['inner-end']), slots.content, slots['content-end']);

  if (!wrap) {
    return ItemContent;
  }

  return /*#__PURE__*/React.createElement("li", _extends({
    ref: elRef,
    id: id,
    style: style,
    className: classNames(className, {
      disabled
    }, colorClasses(props))
  }, extraAttrs), slots['root-start'], ItemContent, isSortableComputed && /*#__PURE__*/React.createElement("div", {
    className: "sortable-handler"
  }), slots.root, slots['root-end']);
});
ListInput.displayName = 'f7-list-input';
export default ListInput;