function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import React, { forwardRef, useRef, useImperativeHandle, useContext } from 'react';
import { useIsomorphicLayoutEffect } from '../shared/use-isomorphic-layout-effect.js';
import { classNames, getExtraAttrs, getSlots, emit, isStringProp } from '../shared/utils.js';
import { colorClasses, actionsAttrs, actionsClasses, routerAttrs, routerClasses } from '../shared/mixins.js';
import { useRouteProps } from '../shared/use-route-props.js';
import { useSmartSelect } from '../shared/use-smart-select.js';
import { useTooltip } from '../shared/use-tooltip.js';
import { watchProp } from '../shared/watch-prop.js';
import { f7ready, f7 } from '../shared/f7.js';
import ListItemContent from './list-item-content.js';
import { ListContext } from '../shared/list-context.js';


/*
const ListItemContent = ({
  props,
  slots,
  inputElRef,
  onChange,
  onClick,
  isMediaComputed,
  isSortableComputed,
  isSortableOppositeComputed,
} = {}) => {
  const {
    radio,
    checkbox,
    value,
    name,
    readonly,
    disabled,
    checked,
    defaultChecked,
    required,
    media,
    header,
    footer,
    title,
    subtitle,
    text,
    after,
    badge,
    badgeColor,
    radioIcon,
    swipeout,
    sortable,
    accordionItem,
  } = props;

};
*/

const ListItem = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    className,
    id,
    style,
    children,
    title,
    link,
    target,
    tabLink,
    tabLinkActive,
    selected,
    mediaItem,
    mediaList,
    divider,
    groupTitle,
    swipeout,
    swipeoutOpened,
    sortable,
    sortableOpposite,
    accordionItem,
    accordionItemOpened,
    smartSelect,
    smartSelectParams,
    noChevron,
    chevronCenter,
    checkbox,
    radio,
    disabled,
    virtualListIndex,
    href
  } = props;
  const listContext = useContext(ListContext);
  const {
    listIsMedia = false,
    listIsSortable = false,
    listIsSortableOpposite = false,
    listIsSimple = false
  } = listContext || {};
  const extraAttrs = getExtraAttrs(props);
  const elRef = useRef(null);
  const linkElRef = useRef(null);
  const f7SmartSelect = useRef(null);

  const onClick = event => {
    if (event.target.tagName.toLowerCase() !== 'input') {
      emit(props, 'click', event);
    }
  };

  const onSwipeoutOverswipeEnter = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutOverswipeEnter');
  };

  const onSwipeoutOverswipeExit = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutOverswipeExit');
  };

  const onSwipeoutDeleted = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutDeleted');
  };

  const onSwipeoutDelete = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutDelete');
  };

  const onSwipeoutClose = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutClose');
  };

  const onSwipeoutClosed = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutClosed');
  };

  const onSwipeoutOpen = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutOpen');
  };

  const onSwipeoutOpened = el => {
    if (elRef.current !== el) return;
    emit(props, 'swipeoutOpened');
  };

  const onSwipeout = (el, progress) => {
    if (elRef.current !== el) return;
    emit(props, 'swipeout', progress);
  };

  const onAccBeforeClose = (el, prevent) => {
    if (elRef.current !== el) return;
    emit(props, 'accordionBeforeClose', prevent);
  };

  const onAccClose = el => {
    if (elRef.current !== el) return;
    emit(props, 'accordionClose');
  };

  const onAccClosed = el => {
    if (elRef.current !== el) return;
    emit(props, 'accordionClosed');
  };

  const onAccBeforeOpen = (el, prevent) => {
    if (elRef.current !== el) return;
    emit(props, 'accordionBeforeOpen', prevent);
  };

  const onAccOpen = el => {
    if (elRef.current !== el) return;
    emit(props, 'accordionOpen');
  };

  const onAccOpened = el => {
    if (elRef.current !== el) return;
    emit(props, 'accordionOpened');
  };

  const onChange = event => {
    emit(props, 'change', event);
  };

  useImperativeHandle(ref, () => ({
    el: elRef.current,
    f7SmartSelect: () => f7SmartSelect.current
  }));
  useTooltip(elRef, props);
  useRouteProps(linkElRef, props);
  watchProp(swipeoutOpened, newValue => {
    if (!swipeout || !elRef.current || !f7) return;

    if (newValue) {
      f7.swipeout.open(elRef.current);
    } else {
      f7.swipeout.close(elRef.current);
    }
  });

  const attachEvents = () => {
    f7ready(() => {
      if (swipeout) {
        f7.on('swipeoutOpen', onSwipeoutOpen);
        f7.on('swipeoutOpened', onSwipeoutOpened);
        f7.on('swipeoutClose', onSwipeoutClose);
        f7.on('swipeoutClosed', onSwipeoutClosed);
        f7.on('swipeoutDelete', onSwipeoutDelete);
        f7.on('swipeoutDeleted', onSwipeoutDeleted);
        f7.on('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
        f7.on('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
        f7.on('swipeout', onSwipeout);
      }

      if (accordionItem) {
        f7.on('accordionBeforeOpen', onAccBeforeOpen);
        f7.on('accordionOpen', onAccOpen);
        f7.on('accordionOpened', onAccOpened);
        f7.on('accordionBeforeClose', onAccBeforeClose);
        f7.on('accordionClose', onAccClose);
        f7.on('accordionClosed', onAccClosed);
      }
    });
  };

  const detachEvents = () => {
    if (!f7) return;
    f7.off('swipeoutOpen', onSwipeoutOpen);
    f7.off('swipeoutOpened', onSwipeoutOpened);
    f7.off('swipeoutClose', onSwipeoutClose);
    f7.off('swipeoutClosed', onSwipeoutClosed);
    f7.off('swipeoutDelete', onSwipeoutDelete);
    f7.off('swipeoutDeleted', onSwipeoutDeleted);
    f7.off('swipeoutOverswipeEnter', onSwipeoutOverswipeEnter);
    f7.off('swipeoutOverswipeExit', onSwipeoutOverswipeExit);
    f7.off('swipeout', onSwipeout);
    f7.off('accordionBeforeOpen', onAccBeforeOpen);
    f7.off('accordionOpen', onAccOpen);
    f7.off('accordionOpened', onAccOpened);
    f7.off('accordionBeforeClose', onAccBeforeClose);
    f7.off('accordionClose', onAccClose);
    f7.off('accordionClosed', onAccClosed);
  };

  useSmartSelect(smartSelect, smartSelectParams, f7SmartSelect, () => elRef.current.querySelector('a.smart-select'));
  useIsomorphicLayoutEffect(() => {
    f7ready(() => {
      if (swipeout && swipeoutOpened) {
        f7.swipeout.open(elRef.current);
      }
    });
  }, []);
  useIsomorphicLayoutEffect(() => {
    attachEvents();
    return detachEvents;
  });
  const slots = getSlots(props);
  let linkEl;
  let itemContentEl;
  const isMediaComputed = mediaItem || mediaList || listIsMedia;
  const isSortableComputed = sortable === true || sortable === false ? sortable : listIsSortable;
  const isSortableOppositeComputed = isSortableComputed && (sortableOpposite || listIsSortableOpposite);

  if (!listIsSimple) {
    // Item Content
    itemContentEl = /*#__PURE__*/React.createElement(ListItemContent, _extends({}, props, {
      slots: slots,
      onChange: onChange,
      onClick: link || href || accordionItem || smartSelect ? undefined : onClick,
      isMediaComputed: isMediaComputed,
      isSortableComputed: isSortableComputed,
      isSortableOppositeComputed: isSortableOppositeComputed
    })); // Link

    if (link || href || accordionItem || smartSelect) {
      const linkAttrs = {
        href: link === true ? '' : link || href,
        target,
        'data-tab': isStringProp(tabLink) && tabLink || undefined,
        ...routerAttrs(props),
        ...actionsAttrs(props)
      };
      const linkClasses = classNames({
        'item-link': true,
        'smart-select': smartSelect,
        'tab-link': tabLink || tabLink === '',
        'tab-link-active': tabLinkActive,
        'item-selected': selected
      }, routerClasses(props), actionsClasses(props));
      linkEl = /*#__PURE__*/React.createElement("a", _extends({
        ref: linkElRef,
        className: linkClasses
      }, linkAttrs, {
        onClick: onClick
      }), itemContentEl);
    }
  }

  const liClasses = classNames(className, {
    'item-divider': divider,
    'list-group-title': groupTitle,
    'media-item': isMediaComputed,
    swipeout,
    'accordion-item': accordionItem,
    'accordion-item-opened': accordionItemOpened,
    disabled: disabled && !(radio || checkbox),
    'no-chevron': noChevron,
    'chevron-center': chevronCenter,
    'disallow-sorting': sortable === false
  }, colorClasses(props));

  if (divider || groupTitle) {
    return /*#__PURE__*/React.createElement("li", {
      ref: elRef,
      id: id,
      style: style,
      className: liClasses,
      "data-virtual-list-index": virtualListIndex,
      onClick: onClick
    }, /*#__PURE__*/React.createElement("span", null, title, children));
  }

  if (listIsSimple) {
    return /*#__PURE__*/React.createElement("li", {
      ref: elRef,
      id: id,
      style: style,
      className: liClasses,
      "data-virtual-list-index": virtualListIndex,
      onClick: onClick
    }, title, children);
  }

  const linkItemEl = link || href || smartSelect || accordionItem ? linkEl : itemContentEl;
  return /*#__PURE__*/React.createElement("li", _extends({
    ref: elRef,
    id: id,
    style: style,
    className: liClasses,
    "data-virtual-list-index": virtualListIndex
  }, extraAttrs), slots['root-start'], swipeout ? /*#__PURE__*/React.createElement("div", {
    className: "swipeout-content"
  }, linkItemEl) : linkItemEl, isSortableComputed && sortable !== false && !isSortableOppositeComputed && /*#__PURE__*/React.createElement("div", {
    className: "sortable-handler"
  }), (swipeout || accordionItem) && slots.default, slots.root, slots['root-end']);
});
ListItem.displayName = 'f7-list-item';
export default ListItem;